import os
import json
import time
import logging
import urllib.request
import urllib.parse
import boto3

logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Áí∞Â¢ÉÂ§âÊï∞
SLACK_SECRET_ID = os.environ['SLACK_SECRET_ID']
SESSIONS_TABLE  = os.environ['SESSIONS_TABLE']

# AWS „ÇØ„É©„Ç§„Ç¢„É≥„Éà
secrets_client = boto3.client('secretsmanager', region_name='ap-northeast-1')
dynamodb       = boto3.client('dynamodb')
bedrock        = boto3.client('bedrock-runtime', region_name='ap-northeast-1')

# Secrets „ÅÆ„É≠„Éº„Éâ
secret_str   = secrets_client.get_secret_value(SecretId=SLACK_SECRET_ID)['SecretString']
secrets      = json.loads(secret_str)
SLACK_TOKEN  = secrets['slack_bot_token']
TMDB_KEY     = secrets['tmdb_key']

TMDB_BASE  = "https://api.themoviedb.org/3"
IMAGE_BASE = "https://image.tmdb.org/t/p/w500"

def init_session(session_id):
    """
    session_id „ÅßÊñ∞Ë¶è„Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰ΩúÊàê„ÄÇ
    preferences=[]„ÄÅround=0„ÄÅttl=‰ªä„Åã„Çâ1ÊôÇÈñìÂæå
    """
    now = int(time.time())
    ttl = now + 3600  # Unix„Ç®„Éù„ÉÉ„ÇØÁßí„Åß1ÊôÇÈñìÂæå
    dynamodb.put_item(
        TableName=SESSIONS_TABLE,
        Item={
            'sessionId':   {'S': session_id},
            'preferences': {'S': json.dumps([])},
            'round':       {'N': '0'},
            'updatedAt':   {'N': str(now)},
            'ttl':         {'N': str(ttl)}
        }
    )

def get_session(session_id):
    """
    DynamoDB „Åã„Çâ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂèñÂæó„ÄÇ„Å™„Åë„Çå„Å∞ init_session „ÇíÂëº„Å∂„ÄÇ
    """
    resp = dynamodb.get_item(
        TableName=SESSIONS_TABLE,
        Key={'sessionId': {'S': session_id}}
    )
    if 'Item' not in resp:
        # „ÉÜ„Éº„Éñ„É´„Å´„Å™„Åë„Çå„Å∞Êñ∞Ë¶èÁôªÈå≤„Åó„Å¶Ëøî„Åô
        init_session(session_id)
        return {'sessionId': session_id, 'round': 0, 'preferences': []}

    item = resp['Item']
    return {
        'sessionId':   session_id,
        'round':       int(item.get('round', {'N': '0'})['N']),
        'preferences': json.loads(item.get('preferences', {'S': '[]'})['S'])
    }

def update_session(session):
    now = int(time.time())
    dynamodb.put_item(
        TableName=SESSIONS_TABLE,
        Item={
            'sessionId':   {'S': session['sessionId']},
            'preferences': {'S': json.dumps(session['preferences'])},
            'round':       {'N': str(session['round'])},
            'updatedAt':   {'N': str(now)}
        }
    )

def delete_session(session_id):
    """
    „Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫ÜÂæå„Å´ÂâäÈô§Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ„ÄÇ
    """
    dynamodb.delete_item(
        TableName=SESSIONS_TABLE,
        Key={'sessionId': {'S': session_id}}
    )

_genre_cache = None

def fetch_keyword_ids(query):
    url = f"{TMDB_BASE}/search/keyword?api_key={TMDB_KEY}&query={urllib.parse.quote_plus(query)}"
    data = json.loads(urllib.request.urlopen(url).read())
    return [kw['id'] for kw in data.get('results', [])]

def tmdb_discover_with_keywords(keyword_ids, n=3):
    params = {
        'api_key':       TMDB_KEY,
        'language':      'ja-JP',
        'sort_by':       'popularity.desc',
        'vote_count.gte':'100',
        'with_keywords': ",".join(map(str, keyword_ids))
    }
    data = json.loads(urllib.request.urlopen(
        f"{TMDB_BASE}/discover/movie?{urllib.parse.urlencode(params)}"
    ).read())
    return data.get('results', [])[:n]

def recommend_movies(query, n=3):
    # 1) „Ç≠„Éº„ÉØ„Éº„ÉâÁµû„ÇäËæº„Åø
    kw_ids = fetch_keyword_ids(query)
    if kw_ids:
        return tmdb_discover_with_keywords(kw_ids, n)

    # 2) „Ç∏„É£„É≥„É´Áµû„ÇäËæº„Åø
    gids = extract_genre_ids(query)
    if gids:
        return tmdb_discover(query, n)

    # 3) „Çø„Ç§„Éà„É´Ê§úÁ¥¢
    results = tmdb_search(query, n)
    if results:
        return results

    # ÊúÄÁµÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Á©∫„É™„Çπ„Éà
    return []

def ask_claude_for_titles(preferences):
    keywords = "„ÄÅ".join(preferences)
    prompt = f"""
‰ª•‰∏ã„ÅÆÊù°‰ª∂„ÇíÊ∫Ä„Åü„ÅôÊò†Áîª„ÇíÊó•Êú¨Ë™û„Çø„Ç§„Éà„É´„Åß 3 Êú¨„ÄÅJSON ÂΩ¢Âºè„ÅßÊïô„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Éª„Ç≠„Éº„ÉØ„Éº„Éâ: {keywords}
„ÉªËøîÂç¥‰æã:
[
  {{ "title": "„ÉÅ„É£„Éº„É™„Éº„Å®„ÉÅ„Éß„Ç≥„É¨„Éº„ÉàÂ∑•Â†¥", "reason": "„ÉÅ„Éß„Ç≥„É¨„Éº„ÉàÂ∑•Â†¥„ÇíÊèè„ÅÑ„ÅüÁâ©Ë™û„Åß‚Ä¶"}}, 
  ‚Ä¶
]
„ÉªÂøÖ„Åö JSON ÈÖçÂàó„Å†„Åë„ÇíËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà‰ΩôË®à„Å™„ÉÜ„Ç≠„Çπ„ÉàÁ¶ÅÊ≠¢Ôºâ
"""
    body = {
        'anthropic_version': 'bedrock-2023-05-31',
        'max_tokens': 512,
        'messages': [{'role':'user', 'content': prompt}]
    }
    res = bedrock.invoke_model(
        modelId="anthropic.claude-3-haiku-20240307-v1:0",
        body=json.dumps(body),
        contentType="application/json",
        accept="application/json"
    )
    text = json.loads(res['body'].read())['content'][0]['text']
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        logger.error("Claude JSON parse error: %s", text)
        return []

def get_movie_details_from_tmdb(title):
    safe_query = urllib.parse.quote_plus(title)
    url = (
        f"{TMDB_BASE}/search/movie?"
        f"api_key={TMDB_KEY}&"
        f"query={safe_query}&"
        f"language=ja-JP&"
        f"include_adult=false"
    )
    try:
        with urllib.request.urlopen(url) as res:
            data = json.loads(res.read())
    except Exception as e:
        logger.error(f"TMDB search error for title={title}: {e}")
        return None

    results = data.get('results', [])
    if not results:
        logger.warning(f"TMDB search returned no results for title={title}")
        return None

    m = results[0]
    return {
        'title':        m.get('title'),
        'release_date': (m.get('release_date','')[:4] or ''),
        'overview':     m.get('overview','ÔºàÊ¶ÇË¶Å„Å™„ÅóÔºâ'),
        'poster_path':  m.get('poster_path')
    }

def fetch_genre_list():
    global _genre_cache
    if _genre_cache is None:
        url = f"{TMDB_BASE}/genre/movie/list?api_key={TMDB_KEY}&language=ja-JP"
        data = json.loads(urllib.request.urlopen(url).read())
        _genre_cache = {g['name'].lower(): g['id'] for g in data.get('genres', [])}
    return _genre_cache

def extract_genre_ids(query):
    genres = fetch_genre_list()
    return [gid for name, gid in genres.items() if name in query.lower()]

def tmdb_discover(query, n=3):
    params = {
        'api_key':       TMDB_KEY,
        'language':      'ja-JP',
        'sort_by':       'popularity.desc',
        'vote_count.gte':'100'
    }
    gids = extract_genre_ids(query)
    if gids:
        params['with_genres'] = ",".join(map(str, gids))
    data = json.loads(urllib.request.urlopen(
        f"{TMDB_BASE}/discover/movie?{urllib.parse.urlencode(params)}"
    ).read())
    return data.get('results', [])[:n]

import urllib.error

def tmdb_search(query, n=3):
    # ÊîπË°å„Çí„Çπ„Éö„Éº„Çπ„Å´ÁΩÆ„ÅçÊèõ„Åà„ÄÅÈï∑„Åô„Åé„ÇãÂ†¥Âêà„ÅØÂàá„ÇäË©∞„ÇÅ
    safe_query = " ".join(query.split())
    safe_query = safe_query[:100]  # ÊúÄÂ§ß100ÊñáÂ≠ó„Åæ„Åß„Å´Âà∂Èôê

    # URL ÁµÑ„ÅøÁ´ã„Å¶
    url = (
        f"{TMDB_BASE}/search/movie?"
        f"api_key={TMDB_KEY}&"
        f"query={urllib.parse.quote_plus(safe_query)}&"
        f"language=ja-JP&"
        f"include_adult=false"
    )
    logger.info(f"[tmdb_search] URL: {url}")
    try:
        resp = urllib.request.urlopen(url)
        data = json.loads(resp.read())
        return data.get('results', [])[:n]
    except urllib.error.HTTPError as e:
        # Êú¨Êñá„ÇíË™≠„Çì„Åß„É≠„Ç∞Âá∫Âäõ
        body = e.read().decode('utf-8', errors='ignore') if hasattr(e, 'read') else ''
        logger.error(f"[tmdb_search] HTTPError {e.code} {e.reason} body={body}")
        return []
    except Exception as e:
        logger.error(f"[tmdb_search] Unexpected error: {e}", exc_info=True)
        return []

def summarize_batch(movies, max_retries=3):
    contents = "\n\n".join(
        f"„Çø„Ç§„Éà„É´: {m['title']}\n„ÅÇ„Çâ„Åô„Åò: {m.get('overview','ÔºàÊ¶ÇË¶Å„Å™„ÅóÔºâ')}"
        for m in movies
    )
    prompt = "Ê¨°„ÅÆÊò†Áîª„Åù„Çå„Åû„Çå„ÅÆ„ÅÇ„Çâ„Åô„Åò„Çí80ÊñáÂ≠ó‰ª•ÂÜÖ„ÅÆÊó•Êú¨Ë™û„ÅßË¶ÅÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n\n" + contents
    body = {
        'anthropic_version':'bedrock-2023-05-31',
        'max_tokens':512,
        'messages':[{'role':'user','content':prompt}]
    }
    for i in range(max_retries):
        try:
            res = bedrock.invoke_model(
                modelId="anthropic.claude-3-haiku-20240307-v1:0",
                body=json.dumps(body),
                contentType="application/json",
                accept="application/json"
            )
            text = json.loads(res['body'].read())['content'][0]['text']
            lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
            summaries = [ln.split(":",1)[1].strip() for ln in lines if ln.startswith("„ÅÇ„Çâ„Åô„Åò:")]
            if len(summaries) == len(movies):
                return summaries
        except Exception:
            time.sleep(2**i)
    # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    return [
        (m.get("overview","")[:80] + "...") if len(m.get("overview",""))>80 else m.get("overview","")
        for m in movies
    ]

def make_blocks(movies, summaries):
    blocks = [
        {'type':'section','text':{'type':'mrkdwn','text':'üé¨ *„Åä„Åô„Åô„ÇÅÊò†Áîª‰∏ÄË¶ß*'}},
        {'type':'divider'}
    ]
    for m, s in zip(movies, summaries):
        if m.get("poster_path"):
            blocks.append({'type':'image','image_url':IMAGE_BASE+m['poster_path'],'alt_text':m['title']})
        blocks.append({
            'type':'section',
            'text':{'type':'mrkdwn','text':f"*{m['title']}* ({m.get('release_date','')[:4]})\n{s}"}
        })
        blocks.append({'type':'divider'})
    if blocks and blocks[-1]['type']=='divider':
        blocks.pop()
    return blocks

def post_ephemeral(channel, user, text=None, blocks=None):
    url = "https://slack.com/api/chat.postEphemeral"
    payload = {"channel":channel, "user":user}
    if text:
        payload["text"] = text
    if blocks:
        payload["blocks"] = blocks
    req = urllib.request.Request(
        url,
        data=json.dumps(payload).encode('utf-8'),
        headers={
            'Authorization': f"Bearer {SLACK_TOKEN}",
            'Content-Type':  'application/json; charset=utf-8'
        }
    )
    with urllib.request.urlopen(req) as res:
        logger.info("postEphemeral response: %s", res.read().decode('utf-8'))

SYSTEM_MSG = (
    "„ÅÇ„Å™„Åü„ÅØ„ÄÅ„É¶„Éº„Ç∂„Éº„Å®‰∏ÄÁ∑í„Å´Êò†Áîª„ÇíË¶≥„ÇãÂèã‰∫∫„Åß„Åô„ÄÇ"
    "„ÅÇ„Å™„Åü„ÅØÂ•≥„ÅÆÂ≠ê„Åß„Åô„ÄÇ"
    "„Éï„É¨„É≥„Éâ„É™„Éº„Å´Ë©±„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    "Êï¨Ë™û„Åß„ÅØ„Å™„Åè„ÄÅ„Çø„É°Âè£„ÅßË©±„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    "„É¶„Éº„Ç∂„Éº„ÅØÊò†Áîª„ÇíÊé¢„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
    "„Åì„Çå„Åã„ÇâÊò†Áîª„Çí„Åä„Åô„Åô„ÇÅ„Åô„Çã„Åü„ÇÅ„Å´„É¶„Éº„Ç∂„Éº„ÅÆÂ•Ω„Åø„ÇíÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
    "„É¶„Éº„Ç∂„Éº„ÅÆÂ•Ω„Åø„ÇíËá™ÁÑ∂„Å´Êéò„Çä‰∏ã„Åí„ÄÅË¶™„Åó„ÅÑÂèãÈÅî„ÅÆ„Çà„ÅÜ„Å´Êé•„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
)

def build_messages(session, user_input):
    prefix = SYSTEM_MSG
    if session['preferences']:
        prefix += "\n„Åì„Çå„Åæ„Åß„ÅÆÂ•Ω„Åø: " + "„ÄÅ".join(session['preferences'])
    return [{'role':'user','content':prefix + "\n„É¶„Éº„Ç∂„Éº: " + user_input}]

def lambda_handler(event, context):
    prompt     = event.get('prompt','')
    channel_id = event.get('channel_id','')
    user_id    = event.get('user_id','')
    #session_id = f"{user_id}#{channel_id}"
    session_id = f"{event['user_id']}#{event['channel_id']}"
    session = get_session(session_id)

    logger.info(f"Session start: {session}")

    # Bedrock Âëº„Å≥Âá∫„Åó
    messages = build_messages(session, prompt)
    res = bedrock.invoke_model(
        modelId="anthropic.claude-3-haiku-20240307-v1:0",
        body=json.dumps({'anthropic_version':'bedrock-2023-05-31','max_tokens':512,'messages':messages}),
        contentType="application/json",
        accept="application/json"
    )
    reply = json.loads(res['body'].read())['content'][0]['text'].strip()

    if len(session['preferences']) < 2:
        # Ë≥™Âïè„Éï„Çß„Éº„Ç∫Ôºö„Ç®„Éï„Çß„É°„É©„É´„ÅßË≥™Âïè„ÇíËøî„Åô
        post_ephemeral(channel_id, user_id, text=reply)
        if session['round'] >= 1:
            session['preferences'].append(event['prompt'])
        session['round'] += 1
        update_session(session)
    else:
        # ‚îÄ‚îÄ Êé®Ëñ¶„Éï„Çß„Éº„Ç∫ (LLMÔºãTMDB „Éè„Ç§„Éñ„É™„ÉÉ„Éâ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # 1) Claude „Å´„Çø„Ç§„Éà„É´ÔºìÊú¨ÔºãÁêÜÁî±„Çí JSON „ÅßÁîüÊàê„Åó„Å¶„ÇÇ„Çâ„ÅÜ
        claude_list = ask_claude_for_titles(session['preferences'])

        # 2) TMDB „ÅßË©≥Á¥∞„ÇíË£úÂÆå„Åó„Å™„Åå„Çâ„Éñ„É≠„ÉÉ„ÇØÁîüÊàêÁî®„É™„Çπ„Éà„Çí‰ΩúÊàê
        movies = []
        for item in claude_list:
            details = get_movie_details_from_tmdb(item['title'])
            if details:
                details['reason'] = item.get('reason','')  # Claude „ÅÆÁêÜÁî±„Çí„Éû„Éº„Ç∏
                movies.append(details)

        # 3) Slack Áî®„ÅÆ blocks „ÇíÁµÑ„ÅøÁ´ã„Å¶
        blocks = [
            {'type':'section','text':{'type':'mrkdwn','text':'üé¨ *„Åä„Åô„Åô„ÇÅÊò†Áîª‰∏ÄË¶ß*'}},
            {'type':'divider'}
        ]
        for m in movies:
            if m.get('poster_path'):
                blocks.append({
                    'type':'image',
                    'image_url': IMAGE_BASE + m['poster_path'],
                    'alt_text': m['title']
                })
            text = f"*{m['title']}* ({m['release_date']})\n{m['reason']}"
            blocks.append({'type':'section','text':{'type':'mrkdwn','text': text}})
            blocks.append({'type':'divider'})
        if blocks and blocks[-1]['type']=='divider':
            blocks.pop()

        post_ephemeral(channel_id, user_id, blocks=blocks)
        delete_session(session_id)

    return {'statusCode': 200}
